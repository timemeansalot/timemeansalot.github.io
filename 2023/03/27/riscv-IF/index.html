<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"timemeansalot.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="RISCV 5 级流水线“取指”部分设计  开源项目中“取指级”参考 本项目“取指级”设计">
<meta property="og:type" content="article">
<meta property="og:title" content="RISC-V 5级流水线取指级设计">
<meta property="og:url" content="http://timemeansalot.github.io/2023/03/27/riscv-IF/index.html">
<meta property="og:site_name" content="timemeansalot">
<meta property="og:description" content="RISCV 5 级流水线“取指”部分设计  开源项目中“取指级”参考 本项目“取指级”设计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/06/27/cVzHaL2BuUrMJQv.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/06/EIQD1LbWTl7OvGy.png">
<meta property="og:image" content="https://s2.loli.net/2023/04/06/SKnDXtylg2pUuso.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/27/D5VAzyJ6pO49sd7.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/27/SiUlO7ZA83y2D5p.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/27/Ob1fdTnopXZYVmF.png">
<meta property="og:image" content="https://s2.loli.net/2023/05/23/OSDrPmAwNLc5iF7.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/27/3YviMgsdQ8Zx1fH.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/27/JaVN9chLMnCQklm.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/27/sVIvNR3qoMp9TPy.png">
<meta property="og:image" content="https://s2.loli.net/2023/06/01/NrQDle4aohYsRmc.png">
<meta property="og:image" content="https://s2.loli.net/2023/11/03/iO5RMLsxEeIoGjy.png">
<meta property="og:image" content="https://s2.loli.net/2023/11/03/ysf9iVFzoBXJwNI.png">
<meta property="og:image" content="https://s2.loli.net/2023/11/03/ONF41mJDGXEVcKC.png">
<meta property="og:image" content="https://s2.loli.net/2023/11/03/qQMTAkGF7NIxyfW.png">
<meta property="og:image" content="https://s2.loli.net/2023/11/03/BHGQX4CUYs6IrEz.png">
<meta property="og:image" content="https://s2.loli.net/2023/11/03/QEt2jCfgzkPR6u7.png">
<meta property="article:published_time" content="2023-03-27T02:57:57.000Z">
<meta property="article:modified_time" content="2024-12-22T02:09:10.097Z">
<meta property="article:author" content="FuJie">
<meta property="article:tag" content="RISC-V">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/06/27/cVzHaL2BuUrMJQv.png">


<link rel="canonical" href="http://timemeansalot.github.io/2023/03/27/riscv-IF/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://timemeansalot.github.io/2023/03/27/riscv-IF/","path":"2023/03/27/riscv-IF/","title":"RISC-V 5级流水线取指级设计"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RISC-V 5级流水线取指级设计 | timemeansalot</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">timemeansalot</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">努力、奋斗</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%8F%96%E6%8C%87%E5%8F%82%E8%80%83"><span class="nav-number">1.</span> <span class="nav-text">开源项目取指参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9C%E5%A3%B3"><span class="nav-number">1.1.</span> <span class="nav-text">果壳</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%9C%82%E9%B8%9F%E4%BD%8E%E5%8A%9F%E8%80%97%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%B8"><span class="nav-number">1.2.</span> <span class="nav-text">蜂鸟低功耗处理器核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%B8%A6%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4%E6%97%B6%E5%8F%96%E6%8C%87%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">不带压缩指令时取指部分设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pc-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.1.</span> <span class="nav-text">PC 重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%B9%E9%BD%90"><span class="nav-number">2.2.</span> <span class="nav-text">指令对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#references"><span class="nav-number">3.</span> <span class="nav-text">References</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4%E6%97%B6%E5%8F%96%E6%8C%87%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.</span> <span class="nav-text">带压缩指令时取指部分设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%88-1"><span class="nav-number">4.1.</span> <span class="nav-text">方案 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%88-2"><span class="nav-number">4.2.</span> <span class="nav-text">方案 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%88-3"><span class="nav-number">4.3.</span> <span class="nav-text">方案 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="nav-number">4.4.</span> <span class="nav-text">三种方案对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%96%E6%8C%87%E6%97%B6%E5%8F%AF%E8%83%BD%E6%9B%B4%E6%96%B0%E7%9A%84-pc-%E5%80%BC"><span class="nav-number">4.5.</span> <span class="nav-text">取指时可能更新的 PC 值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dual-fifo"><span class="nav-number"></span> <span class="nav-text">Dual FIFO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E6%8C%87ping-pong-fifo%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">取指Ping Pong FIFO设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.</span> <span class="nav-text">改进设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ping-pong-fifoppf%E6%80%9D%E6%83%B3"><span class="nav-number">1.2.1.</span> <span class="nav-text">Ping Pong FIFO(PPF)思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">硬件实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">1.3.</span> <span class="nav-text">性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E8%BF%94%E5%9B%9E%E5%8A%A0%E9%80%9F"><span class="nav-number">1.3.1.</span> <span class="nav-text">中断返回加速</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E7%9A%84%E7%A1%AC%E4%BB%B6"><span class="nav-number">1.3.2.</span> <span class="nav-text">增加的硬件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dual-fifo-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">Dual FIFO 性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%BA%A6%E5%AE%9Ac-convention"><span class="nav-number">2.1.</span> <span class="nav-text">C约定(C convention)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC"><span class="nav-number">2.3.</span> <span class="nav-text">分支跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD"><span class="nav-number">2.4.</span> <span class="nav-text">异常&amp;中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E9%87%8F%E5%8C%96"><span class="nav-number">2.5.</span> <span class="nav-text">数学量化</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FuJie"
      src="https://s2.ax1x.com/2019/03/19/AuQxUJ.jpg">
  <p class="site-author-name" itemprop="name">FuJie</p>
  <div class="site-description" itemprop="description">花丛才有蜜蜂，粪坑只有苍蝇</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/timemeansalot" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;timemeansalot" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/timemeansalot@gmail.com" title="E-Mail → timemeansalot@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://timemeansalot.github.io/2023/03/27/riscv-IF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s2.ax1x.com/2019/03/19/AuQxUJ.jpg">
      <meta itemprop="name" content="FuJie">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="timemeansalot">
      <meta itemprop="description" content="花丛才有蜜蜂，粪坑只有苍蝇">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RISC-V 5级流水线取指级设计 | timemeansalot">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RISC-V 5级流水线取指级设计
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-27 10:57:57" itemprop="dateCreated datePublished" datetime="2023-03-27T10:57:57+08:00">2023-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-22 10:09:10" itemprop="dateModified" datetime="2024-12-22T10:09:10+08:00">2024-12-22</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>RISCV 5 级流水线“取指”部分设计</p>
<ol type="1">
<li>开源项目中“取指级”参考</li>
<li>本项目“取指级”设计 <span id="more"></span></li>
</ol>
<p>[TOC]</p>
<blockquote>
<p>取指级需要处理的 2 个关键问题：1. PC 重定向 2. 指令对齐</p>
</blockquote>
<h2 id="开源项目取指参考">开源项目取指参考</h2>
<h3 id="果壳">果壳</h3>
<figure>
<img src="https://s2.loli.net/2023/06/27/cVzHaL2BuUrMJQv.png"
alt="image-20230627130147655" />
<figcaption aria-hidden="true">image-20230627130147655</figcaption>
</figure>
<ol type="1">
<li><p>取指</p>
<blockquote>
<p>功能: 取指、更新 PC、指令对齐</p>
</blockquote>
<ol type="1">
<li>根据 BP 的结果更新 PC</li>
<li>根据 PC 从<code>I$</code>中取数据，一次取 1 个 Cache Line(64bits
的数据</li>
<li>取指数据会被压入到指令对齐缓冲<code>IAB</code>，由 IAB
识别指令边界，得到指令</li>
</ol></li>
<li><p>分支预测器</p>
<blockquote>
<p>功能：三种类型的混合预测器</p>
</blockquote>
<ol type="1">
<li>默认 PC+8</li>
<li>BTB：512 entry，每个 entry 的数据如下图所示： -&gt; JAL, JALR <img
src="https://s2.loli.net/2023/06/27/pP3GTXNriet15Ec.png"
alt="image-20230627130221058" /></li>
<li>RAS：16 entry, 每个 entry 是 32bit 的 PC 地址 -&gt; call, ret</li>
<li>PHT: 512entry，每个 entry 是 2bit 预测器-&gt;
处理条件分支指令(B-Type Instructions)</li>
</ol>
<blockquote>
<p>RAS 和 PHT 用<u>同步写异步读的寄存器</u>来实现, BTB
由于面积较大而通过<u>快速 SRAM</u> 来实现, 因此在访问前者时需要将取指 PC
缓存一拍.</p>
</blockquote></li>
<li><p>CSR</p>
<blockquote>
<p>功能：判断 trap 发生、类型，传递给 WB</p>
</blockquote>
<ol type="1">
<li>CSR 单元处于 EXE 级，配合 CSR Register 实现权限控制及对 trap
处理</li>
<li>Load Store 指令由 LSU 判断是否发生 exception，如果发生则由 LSU 将
excption 信息转发给 CSR 单元<br />
果壳项目中：<u>EXE 级和 MEM 级被合并成了同一个</u>, EXE 后面直接跟的是
WB, 其 EXE 可能占用多个周期</li>
<li>其他指令在 decode 阶段就可以判断其 exception，exception 信息由 ID
经过流水线传递给 CSR 单元</li>
</ol></li>
<li><p>WB</p>
<blockquote>
<p>功能：<strong>传递重定向 PC</strong> 及写回数据(writ bank data)</p>
</blockquote>
<ol type="1">
<li>重定向(redirection)：当 EXE 发现 BP 错误、CSR 判断 trap
发生的时候，触发重定向 -&gt; 发送正确的 PC 给 IF</li>
<li>写回：将需要写回给 rd 的数据传回给 ISU，由 ISU 写入到 Register
File</li>
</ol></li>
</ol>
<h3 id="蜂鸟低功耗处理器核">蜂鸟低功耗处理器核</h3>
<figure>
<img src="https://s2.loli.net/2023/04/06/EIQD1LbWTl7OvGy.png"
alt="e203 storage system" />
<figcaption aria-hidden="true">e203 storage system</figcaption>
</figure>
<ol type="1">
<li><p>采用 ITCM</p>
<ul>
<li>蜂鸟采用 64bits 的 SRAM 作为 ITCM</li>
<li>面积更加紧凑、顺序读取 64bits 的数据，其只需要 1 次动态功耗</li>
</ul>
<figure>
<img src="https://s2.loli.net/2023/04/06/SKnDXtylg2pUuso.png"
alt="ITCM" />
<figcaption aria-hidden="true">ITCM</figcaption>
</figure></li>
<li><p>指令对齐:</p>
<ul>
<li><p>leftover buffer,<br />
蜂鸟采用 leftover buffer 来实现指令对齐，存储指令的高 16bits 到 leftover
buffer：连续取指的时候，1 个 cycle
可以解决指令不对齐问题；非连续取指的时候，必须 2 个 cycle
才可以解决指令不对齐问题 <img
src="https://s2.loli.net/2023/06/27/E5l3Lv1VtTP4cwI.png"
alt="image-20230627130320584" /></p></li>
<li><p>2 bank SRAM</p>
<figure>
<img src="https://s2.loli.net/2023/06/27/D5VAzyJ6pO49sd7.png"
alt="image-20230627130610648" />
<figcaption aria-hidden="true">image-20230627130610648</figcaption>
</figure></li>
</ul></li>
<li><p>蜂鸟支持 C 压缩指令集，因此它需要考虑指令对齐的问题(16bit 和
32bit 的指令混合存储在 I-memory 中)</p>
<ul>
<li>RISCV 指令格式：32bit 的指令，其低 2bit 一定是 11；否则是 16bit
的指令</li>
<li>如果只支持 32bits 的指令，则可以默认取指地址低 2bit 为
00（默认指令恒 4B 对齐）</li>
</ul></li>
<li><p>蜂鸟 EXE
级在遇到<u>分支预测错误、trap</u>的时候，都会触发重定向，会返回给 IF
<img src="https://s2.loli.net/2023/06/27/SiUlO7ZA83y2D5p.png"
alt="image-20230627130908630" /></p>
<ul>
<li>BP 错误：条件跳转指令的结果由 EXE 级的 ALU 计算得到</li>
<li>CSR: 蜂鸟只支持机器模式、没有虚拟地址不存在 page 缺失相关的异常</li>
</ul>
<blockquote>
<p>中断和异常的实现时处理器实现非常关键的一部分，同时也是最为烦琐的一部分。得益
于 RISC-V 架构对于中断和异常机制的简单定义，蜂鸟 E200
对其进行硬件实现的代价很小。
即便如此，异常和中断相关的源代码相比其他模块而言，仍然非常细琐繁杂</p>
</blockquote></li>
</ol>
<h2 id="不带压缩指令时取指部分设计">不带压缩指令时取指部分设计</h2>
<blockquote>
<p>取指阶段主要需要解决的问题是：<u>PC 重定向、指令对齐</u></p>
</blockquote>
<ol type="1">
<li><p>PC -&gt; I-Memory -&gt; Instruction: 一共有 2 个 cycle 的
delay，需要保证 PC 和 instruction
在流水线上是匹配的，在代码里使用了一个额外的<code>pc_delay</code>寄存器来提供额外一个
cycle 的 PC 延迟 <img
src="https://s2.loli.net/2023/06/27/hsogZdXDfIykOTw.png"
alt="image-20230627131000094" /></p></li>
<li><p>当流水线刷新之后，新地址对应的指令在 2 个 cycle 之后送到 ID Stage
，因此其后续两个 cycle 的指令都是无效指令，看作 2 条 nop 指令</p></li>
<li><p>EXE 如果和 ID 同时发来了重定向信号，则 EXE 的信号优先级更高：因为
EXE 的指令更老</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipelineIF.v</span></span><br><span class="line"><span class="keyword">assign</span> pc_mux = (taken_e_i == <span class="number">1&#x27;b1</span>) ? redirection_e_i:</span><br><span class="line">  							(taken_d_i == <span class="number">1&#x27;b1</span>) ? redirection_d_i : pc_register;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="pc-重定向">PC 重定向</h3>
<ol type="1">
<li><p>IF 没有分支预测，PC+=2<br />
<u>IF 阶段设置有一个 FIFO，最多存储 5*16bits 的数据</u>，该 FIFO
的设置是因为我们不知道指令是 16bits 的还是 32bits 的。</p>
<p><strong>重定向发生的时候，I-Mem 直接采用重定向的 PC
作为取值地址</strong>，可以避免 1 个 cycle 的 penalty 重定向的 PC
有如下可能的原因：</p>
<ol type="1">
<li>系统初始化 reset 的时候，需要更新 PC 为初始化地址</li>
<li>顺序 PC</li>
<li>ID 阶段的静态分支预测，需要发送预测的 PC 和跳转信号到 IF</li>
<li>EXE 阶段若判断 ID 的分支预测错误，需要发送正确的 PC 和跳转信号到
IF</li>
<li>MEM 阶段当异常和中断发生的时候，需要 CSR 单元发送 对应的地址
和跳转信号到 IF
<ul>
<li>illegal_addr, interrupt_addr, debug_addr</li>
<li>此外，对于<code>mret</code>指令，MEM 阶段需要从 CSR 寄存器中返回 EPC
的值到 IF</li>
</ul></li>
</ol>
<p><strong>在引入 MEM 阶段的重定向信息之前，只有 ID，EXE 会导致 IF 的 PC
重定向；引入 MEM 的重定向之后，对应的 pipeline
冲刷逻辑，都变得更加复杂</strong></p></li>
<li><p>ID 采用静态分支预测，如果解码判断是分支指令，会计算 target
PC<br />
不会冲刷流水线 <img
src="https://s2.loli.net/2023/06/27/B5KJ7oQVm4SY3a6.png"
alt="image-20230627131128707" /></p></li>
<li><p>EXE 的 ALU 会对条件分支指令的结果进行判断，如果 ID 判断错误，EXE
会产生重定向 PC<br />
冲刷 1 条流水线 <img
src="https://s2.loli.net/2023/06/27/EUNcdCjw3Q12Mgh.png"
alt="image-20230627131140165" /></p></li>
<li><p>MEM 的 CSR 单元会判断 trap 是否发生，如果发生 EXE 也会产生重定向
PC<br />
冲刷 2 条流水线 <img
src="https://s2.loli.net/2023/06/27/zmbJUyurotLqQiN.png"
alt="image-20230627131150989" /></p></li>
</ol>
<h3 id="指令对齐">指令对齐</h3>
<p>ITCM 占 64kB</p>
<ol type="1">
<li><p>FIFO 工作原理</p>
<ul>
<li>FIFO 每次从 I-memory 读取 2x16 的数据</li>
<li>FIFO 中数据少于等于 3 的时候，FIFO 会从 I-memory 中读取数据，避免
underflow</li>
<li>FIFO 中数据大于 3 的时候，FIFO 会停止从 I-memory 中读取数据，避免
overflow</li>
<li>当 ID 发现指令是 32bits 的时候，FIFO 头部 2 条数据会被 POP，FIFO
数据量-2</li>
<li>当 ID 发现指令是 16bits 的时候，FIFO 头部 1 条数据会被 POP，FIFO
数据量-1</li>
</ul></li>
<li><p>采用 2 bank SRAM 作为 I-Memory, 两个 bank 的 SRAM 都是 16bits
的位宽，配合 FIFO 可以处理 32bits 指令不对齐的情况, 其工作原理如下：</p>
<ul>
<li><p>顺序读取: 顺序读取的时候不存在 PC 重定向，FIFO 不需要刷新</p>
<ol type="1">
<li>连续读 16bits 的指令：每次消耗 FIFO 中 1 条数据，读入 2 条数据到
FIFO，FIFO 数据量会逐步增加，当大于等于 3 的时候，FIFO 就不会继续从
I-memory 读取数据了</li>
<li>连续读 32bits 的指令：每次消耗 FIFO 中 2 条数据，读入 2 条数据到
FIFO，FIFO 数据量会保持恒定，FIFO 会继续从 I-memory 读取数据了</li>
<li>混合读取 16bits 和 32bits 的数据：上述两种方式的混合</li>
</ol></li>
<li><p>PC 重定定向: 当发生 PC 重定向之后，FIFO
中现存的所有数据都是无效的，需要被刷新，并且下一个周期从 I-memory
中读出的指令也是无效的指令，也需要被丢弃; 在第二个周期读出的指令是重定向
PC 对应的指令，会被 PUSH 到 FIFO 中</p></li>
</ul></li>
</ol>
<blockquote>
<p>PS: 在只支持 32bits 指令的处理器中，JALR 指令可能会计算得到的 PC 不是
4B 对齐的，但是在模拟器中测试该场景的时候，模拟器默认忽略了 PC 最低
2bits，导致不对齐的 PC 也可以从 I-memory 中读取指令，没有触发
exception.</p>
</blockquote>
<h2 id="references">References</h2>
<ol type="1">
<li><a
target="_blank" rel="noopener" href="https://oscpu.github.io/NutShell-doc/%E6%B5%81%E6%B0%B4%E7%BA%BF/ifu.html">Nutshell
Documents</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/riscv-mcu/e203_hbirdv2">riscv-mcu/e203_hbirdv2</a></li>
</ol>
<h2 id="带压缩指令时取指部分设计">带压缩指令时取指部分设计</h2>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />TODO: new pc source,
refer to the essay</label></li>
<li><label><input type="checkbox" checked="" />TODO：new instruction pc
must by used by EXE stage when revise SBP decision, sbp taken, alu not
taken&lt;-need the third instruction after current instruction method 1:
pass pc+2 and pc+4(more register), method 2: pass pc to exe and
calculate pc+4 or pc+2 in exe(more calculation)</label></li>
<li><label><input type="checkbox" checked="" />TODO: new diagram of IF
with compressed instruction: 2 SRAM bank, FIFO, new pc
logic</label></li>
<li><label><input type="checkbox" checked="" />TODO: with 2 bank SRAM,
how to initiate data into SRAM? In testbench, write to 1 bank SRAM, then
fill the two SRAM by the SRAM in testbench.</label></li>
<li><label><input type="checkbox" checked="" />TODO: pc increment logic
when find compress instruction</label></li>
<li><label><input type="checkbox" checked="" />TODO: pc_plus4 change
into pc_next, because we next pc could be pc+2</label></li>
<li><label><input type="checkbox" checked="" />TODO: add a summary of
how each method solve the above key problem</label></li>
</ul>
<p><strong>支持压缩指令时，IF Stage 设计需要考虑的要点</strong>：</p>
<ol type="1">
<li><p>当压缩指令跟整数指令混合存放的时候，如何处理整数指令取指问题？
&gt; 由于 RISC-V 在支持压缩指令的情况下，16bits 的压缩指令跟 32bits
的整数指令，是混合存储的， &gt; 因此整数指令可能不是按照 4B
对齐的，微架构需要对整数指令不对齐的情况做处理。</p></li>
<li><p>存在压缩指令的时候，如何将 ID Stage 的指令跟指令对应的 PC 相匹配?
&gt; 因为 SBP 计算 redirection_pc 的时候，需要用到 pc &gt; pc
其实是建立的对压缩、整数指令的判断的基础上的</p></li>
<li><p>存在压缩指令的时候，IF 顺序取指的时候如何增加 pc? &gt;
取到压缩指令的时候，pc+=2；取到整数指令的时候 pc+=4</p></li>
<li><p>SBP 预测跳转，ALU 验证不跳转的时候，EXE 如何获得正确的
<code>pc_next_next</code> 发送给 IF？</p>
<ol type="1">
<li>ID Stage 的 SBP 预测跳转时，会将 IF 的取指地址修改为
prediction_addr</li>
<li>EXE Stage 的 ALU 如果判断不跳转，需要将 IF 的取指地址更改为
pc_next_next, 并且冲刷到 prediction_addr 取出的指令</li>
</ol>
<figure>
<img src="https://s2.loli.net/2023/06/27/Ob1fdTnopXZYVmF.png"
alt="image-20230627131305174" />
<figcaption aria-hidden="true">image-20230627131305174</figcaption>
</figure></li>
</ol>
<h3 id="方案-1">方案 1</h3>
<p><strong>核心思想</strong>：采用 32 位宽的 SRAM，每次取指 4B
的数据，采用 leftover buffer 存储上次取指的高
16bits，用于判断指令是否是压缩指令、完成 32bits 指令的拼接</p>
<blockquote>
<p>参考了蜂鸟的设计、以及论文《用于计量的嵌入式 RISC-V 处理器设计及 MCU
实现》</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/05/23/OSDrPmAwNLc5iF7.png"
alt="压缩指令与整数指令存储组合" /> <img
src="https://s2.loli.net/2023/05/23/XS4AhVs71Wmwl6r.png"
alt="压缩指令译码器指令判别流程图" /></p>
<ol type="1">
<li><p>leftover buffer 的作用：</p>
<ol type="1">
<li>存储 32bits 指令的低 16bits 数据</li>
<li>判断压缩指令和整数指令的标志</li>
</ol></li>
<li><p>该方案的优点：顺序取指的时候，PC+=4 即可; 取指单位 4B，PC
最后两位取指的时候直接当<code>00</code>来处理</p></li>
<li><p>该方案的缺点：</p>
<ol type="1">
<li>压缩指令跟整数指令的组合一共有 5 种，每次取 4B
数据之后，都需要经过复杂的判断才可以判断出指令的种类</li>
<li>32bits 指令不对齐的情况下，需要跟 leftover buffer
中的数据拼接才可以得到真正的整数指令</li>
<li>将指令与其对应的 pc 对应不方便（因为指令可能不是直接按照 pc 从 SRAM
中取出来的，而是跟 leftover buffer 拼接而成的）</li>
<li>地址重定向发生的时候，如果重定向地址不是 4B 对齐的，需要 2 次访问
SRAM 才可以拼成一个整数指令</li>
</ol></li>
</ol>
<h3 id="方案-2">方案 2</h3>
<p><strong>核心思想</strong>：在方案 1 的基础上，将 32bits 的 SRAM
拆分成 2 块 16bits 的 SRAM，这样取指的粒度从 4B 变成了 2B</p>
<figure>
<img src="https://s2.loli.net/2023/06/27/3YviMgsdQ8Zx1fH.png"
alt="image-20230627131329377" />
<figcaption aria-hidden="true">image-20230627131329377</figcaption>
</figure>
<ol type="1">
<li><p>整数指令对齐：利用 2 back SRAM 来处理非对齐地址，取指的时候，根据
addr 是否 4B 对齐，分为两种情况</p>
<ol type="1">
<li>addr 是 4B
对齐：<code>instr=&#123;Left[addr&gt;&gt;2], Right[addr&gt;&gt;2]&#125;</code>,
如图 pc==8 的情况</li>
<li>addr 是 2B
对齐：<code>instr=&#123;Left[Right[addr&gt;&gt;2+1], Left[addr&gt;&gt;2]&#125;</code>，如图
pc==2 的情况 <img
src="https://s2.loli.net/2023/06/27/K3c12ZuPn7vH9JX.png"
alt="image-20230627131344666" /></li>
</ol></li>
<li><p>压缩指令判断，由于不存在 leftover
buffer，判断压缩指令与整数指令，只需要看 instr[1:0]即可,
上图中红色部分就是在 ID 阶段通过比较指令最低 2bits
来判断指令是否是压缩指令</p>
<ol type="1">
<li><code>instr[1:0]==11</code>: pc+=4</li>
<li><code>instr[1:0]!=11</code>: pc+=2</li>
</ol>
<p>取出的指令<code>instr</code>可能的情况一共有 3 种：<code>I</code>,
<code>C+C</code>, <code>I+C</code>, 针对 <code>C+C</code> 的情况，当作
<code>I+C</code> 处理，以简化流水线冲刷的逻辑(代价是 <code>C+C</code>
本可以只访问一次 SRAM 的)。</p>
<blockquote>
<p>32bits 的压缩指令，不管是<code>C+C</code>还是<code>I+C</code>，送到
ID 的 extending unit(EU)之后，EU 都会将其低 16bits
压缩指令部分扩展成对应的 32bits 整数指令</p>
</blockquote></li>
<li><p>如何匹配每条指令和对应的 pc:<br />
在 IF Stage 取指的时候，每条指令都是按照 pc_sel
取指的，因此每条指令都对应 pc_sel 的值</p></li>
<li><p>pc_next_next 如何计算： 由于压缩指令、整数指令混合存储，因此
pc_next_next 的值依赖于当前指令以及后续那条指令的类型， 假设指令序列为
3-&gt;2-&gt;1，令指令 1 对应的地址为 pc</p>
<ol type="1">
<li>计算 pc_next:
<ul>
<li>指令 1 是压缩指令：pc_next=pc+2</li>
<li>指令 1 不是压缩指令：pc_next=pc+4</li>
</ul></li>
<li>计算 pc_next_next:
<ul>
<li>指令 2 是压缩指令：pc_next_next=pc_next+2</li>
<li>指令 2 不是压缩指令：pc_next_next=pc_next+4</li>
</ul></li>
</ol></li>
<li><p>该方案的优点：</p>
<ol type="1">
<li>没有 leftover buffer，压缩指令判读变得简单、32bits
指令也不需要拼接</li>
<li>将指令跟 PC 对应很简单，指令对应的 PC 一定是 pc_sel</li>
<li>地址重定向发生的时候，即使 PC 不是 4B 对齐，也可以一个 cycle 就从
SRAM 中取出指令</li>
</ol></li>
<li><p>该方案的缺点：</p>
<ol type="1">
<li>IF 阶段计算 pc_next
的逻辑依赖于<strong>对取出的指令的判断</strong>，从而判断 pc_next 等于
pc+4 还是 pc+2</li>
<li>两个相邻的压缩指令(<code>C+C</code>类型)，明明可以访问 1 次
SRAM，但是却需要访问 2 次</li>
</ol></li>
</ol>
<h3 id="方案-3">方案 3</h3>
<p><strong>核心思想</strong>：在方案 2 的基础上，将取出的指令 instr 放到
FIFO 中，节约<code>C+C</code>类型指令存储的访问 SRAM</p>
<blockquote>
<p>Q: 是否 4*16 的 FIFO 也能保证没有 overflow?</p>
</blockquote>
<figure>
<img src="https://s2.loli.net/2023/06/27/JaVN9chLMnCQklm.png"
alt="image-20230627131400942" />
<figcaption aria-hidden="true">image-20230627131400942</figcaption>
</figure>
<ol type="1">
<li>整数指令对齐：取指逻辑跟方案 2 相同，差别在于：
<ol type="1">
<li>取出的指令放到 FIFO 中，而不是放到 IF/ID pipeline register 中</li>
<li>FIFO 没有空间的时候，不会从 I-Memory 中取指令放到 FIFO 中</li>
</ol></li>
<li>FIFO 逻辑(Question -&gt; FIFO 容量为 4 能否满足需求？)
<ol type="1">
<li>避免 underflow：由于 ID 一次最多取走 32bits 的数据，因此 FIFO <span
class="math inline">\(count \le 2\)</span> 的时候，FIFO 允许写入</li>
<li>避免 overflow：若令 FIFO 总容量为 4，则 FIFO <span
class="math inline">\(count\ge3\)</span> 时，FIFO 不能写入</li>
</ol></li>
<li>压缩指令判断：从 FIFO 头部取出 32bits 的指令送到 ID，有 ID Stage
比较指令最低 2bits 来判断是否是压缩指令
<ol type="1">
<li>如果是压缩指令，则 FIFO 将头部 16bits 指令 pop，FIFO 容量-1</li>
<li>如果是整数指令，则 FIFO 将头部 32bits 指令 pop，FIFO 容量-2</li>
</ol></li>
<li>如何匹配每条指令和对应的 pc:
<ol type="1">
<li>方案 3 中，取指的 pc 跟每条指令的 pc 不是一一对应关系，取指 pc
只负责在 FIFO 有空间的时候， 顺序的取指放入到 FIFO 中</li>
<li>方案 3 中每条指令对应的 PC 在 ID Stage 中维护，ID Stage 只会在 reset
或者重定向发生的时候， 才会从 IF 得到 pc</li>
</ol></li>
<li>pc_next_next 如何计算？跟方案 2 不同处有：
<ol type="1">
<li>方案 3 在 ID Stage 再判断是否是压缩指令，所以 pc_next 在 ID Stage
计算得到</li>
<li>pc_next_next 在 EXE Stage 计算得到</li>
</ol></li>
<li>该方案的优点：
<ol type="1">
<li>取指的 pc 不需要判断指令是否是压缩指令，默认+4 即可</li>
<li>针对<code>C+C</code>类型的指令，只用访问 SRAM 一次</li>
</ol></li>
<li>该方案的缺点：
<ol type="1">
<li>指令跟取指 pc 对应逻辑比较复杂</li>
<li>相比于方案 2，计算 pc_next_next 需要额外在 EXE Stage
多引入一个加法器</li>
<li>IF Stage 引入了 FIFO，增加了复杂度</li>
</ol></li>
</ol>
<h3 id="三种方案对比">三种方案对比</h3>
<ol type="1">
<li>方案 1 的设计是最简单的，其明显的缺点在于：
<ol type="1">
<li>压缩指令跟整数指令的组合复杂，因此判断逻辑也很复杂</li>
<li>重定向发生的时候，如果 redirection_pc 不是 4B 对齐的，需要 2
次访存才可以取到整数指令</li>
</ol></li>
<li>方案 2 在方案 1 的基础上将 1 bank sram 改进为 2 bank sram
<ol type="1">
<li>解决了方案 1 中明显的缺点</li>
<li>仍然存在的问题在于：取指 pc 的计算，需要判断从 I-Memory
中取出的指令是否是压缩指令</li>
</ol></li>
<li>方案 3 在方案 2 的基础上，引入了 FIFO，并且将压缩指令的判断推迟到了
ID Stage
<ol type="1">
<li>取指 pc 不用依赖于指令的类型</li>
<li>付出的代价是
<ol type="1">
<li>FIFO 带来的复杂度</li>
<li>指令跟 pc 的对应关系，变得比方案 2 复杂</li>
<li>需要在 EXE 阶段增加额外的加法器来计算 pc_next_next</li>
</ol></li>
</ol></li>
</ol>
<blockquote>
<p>综上：如果暂时没有更好的解决方案，我们可以在方案 2、3
之间选择一个</p>
</blockquote>
<h3 id="取指时可能更新的-pc-值">取指时可能更新的 PC 值</h3>
<figure>
<img src="https://s2.loli.net/2023/06/27/sVIvNR3qoMp9TPy.png"
alt="image-20230627131422562" />
<figcaption aria-hidden="true">image-20230627131422562</figcaption>
</figure>
<p>IF Stage
可能的取指地址有如下一些情况，其优先级：<code>TOP &gt; EXE &gt; ID &gt; IF</code></p>
<ol type="1">
<li><p>TOP(reset_addr): 可以由 TOP 传给 IF Stage，也可以在 IF Stage
里默认一个 reset_addr</p></li>
<li><p>IF Stage(pc_register_addr): pc_register 的输出</p></li>
<li><p>ID Stage(prediction_addr): SBP
判断跳转发生时，对应的跳转地址</p></li>
<li><p>EXE Stage(redirection_addr):</p>
<ul>
<li><p>ALU 判断 SBP 预测错误时，需要给出 redirection_pc_addr</p></li>
<li><p>CSR</p>
<ol type="1">
<li>mret 指令，需要将 epc 的地址作为下一条指令的地址</li>
<li>非法指令，需要跳转到 trap_vector 地址</li>
<li>外部中断发生时，需要跳转到 trap_vector 地址</li>
<li>debug 发生时，需要跳到 debug 对应地址</li>
</ol>
<blockquote>
<p>PS: 根据 CSR 设计不同，上述四个 addr 可能会存在相同的情况</p>
</blockquote></li>
</ul></li>
</ol>
<p><img src="https://s2.loli.net/2023/06/01/NrQDle4aohYsRmc.png"
alt="verification" /> 测试的情况有：</p>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />地址 4B
对齐，顺序取指</label></li>
<li><label><input type="checkbox" checked="" />地址非 4B
对齐，顺序取指</label></li>
<li><label><input type="checkbox"
checked="" />地址重定向发生后两个周期，顺利取出指令到 IR(Instruction
Register)</label></li>
<li><label><input type="checkbox" checked="" />顺序取指时：</label>
<ul class="task-list">
<li><label><input type="checkbox" checked="" />ID
读取压缩指令（16bits)</label></li>
<li><label><input type="checkbox" checked="" />ID
读取整数指令（32bits）</label></li>
<li><label><input type="checkbox" checked="" />流水线
stall（0bits）</label></li>
</ul></li>
</ul>
<h1 id="dual-fifo">Dual FIFO</h1>
<h2 id="取指ping-pong-fifo设计">取指Ping Pong FIFO设计</h2>
<h3 id="问题描述">问题描述</h3>
<blockquote>
<p>IF
Stage的FIFO在遇到指令重定向到时候，会导致冲刷掉其内部所有的预取指令，是很大的浪费</p>
</blockquote>
<figure>
<img src="https://s2.loli.net/2023/11/03/iO5RMLsxEeIoGjy.png"
alt="image-20231028053834305" />
<figcaption aria-hidden="true">image-20231028053834305</figcaption>
</figure>
<ol type="1">
<li><p>由于FIFO容量是5*16，当所有指令都是压缩指令的时候，指令的冲刷会导致至多4条有效指令被浪费了</p></li>
<li><p>单一FIFO的重定向逻辑如下:</p>
<figure>
<img src="https://s2.loli.net/2023/11/03/ysf9iVFzoBXJwNI.png"
alt="image-20231028073735678" />
<figcaption aria-hidden="true">image-20231028073735678</figcaption>
</figure>
<ul>
<li>cycle0发生重定向</li>
<li>cycle1冲刷掉FIFO里所有的指令，并且从I-Memory里按照sequential_pc取出指令放到FIFO头部(该指令在流水线上的指令可能会被Hazard
Unit控制冲刷掉)</li>
<li>cycle2按照redirection_pc从I-Memory里取出指令放到FIFO头部</li>
</ul></li>
</ol>
<h3 id="改进设计">改进设计</h3>
<blockquote>
<p>核心思想是：尽可能保存预取指令，避免浪费</p>
</blockquote>
<h4 id="ping-pong-fifoppf思想">Ping Pong FIFO(PPF)思想</h4>
<ol type="1">
<li>采用2个FIFO取指队列，当重定向产生导致FIFO需要冲刷的时候，暂时不要冲刷FIFO；
将指令暂时写入到另一个空闲的FIFO当中</li>
<li>重定向返回的时候，从之前的FIFO的去指令，利用预取的指令</li>
</ol>
<h4 id="硬件实现">硬件实现</h4>
<ol type="1">
<li><p>硬件上为了支持PPF需要实现的功能有:</p>
<ul>
<li><p>额外的FIFO(5*16bits寄存器)</p></li>
<li><p>指令PC计算逻辑 &amp; 旧指令选择逻辑</p>
<ul>
<li>重定向发生的时候，提前根据重定向类型，将重定向返回时的指令对应的pc存储起来，
那么在重定向返回的时候，可以通过该寄存器的值快速得到指令对应的pc</li>
<li>旧指令选择逻辑需要根据重定向</li>
</ul></li>
<li><p>ping pong FIFO控制逻辑</p>
<ul>
<li>使用free[1:0]寄存器来表示ping pong FIFO里的内容是否有效</li>
<li><strong>重定向发生的时候</strong>:
如果一个FIFO里的内容是无效的，则可以在重定向发生的时候，将新的指令写入到该FIFO里</li>
<li><strong>重定向发生的时候</strong>，假如另一个FIFO空闲，其free寄存器对应字段拉低</li>
<li><strong>重定向返回的时候</strong>，将当前FIFO对应的free寄存器位拉高</li>
</ul></li>
</ul></li>
<li><p>硬件实现</p>
<figure>
<img src="https://s2.loli.net/2023/11/03/ONF41mJDGXEVcKC.png"
alt="image-20231028074746545" />
<figcaption aria-hidden="true">image-20231028074746545</figcaption>
</figure>
<ul>
<li>2个5*16的FIFO</li>
<li>pc_instr寄存器用于记录FIFO头部的指令对应的pc</li>
<li>free寄存器用于记录FIFO是否空闲，假如FIFO内部没有有效数据，则FIFO空闲</li>
<li>waiting_for寄存器记录FIFO内指令对应内容，用于判断重定向的返回</li>
</ul></li>
<li><p>举例说明</p>
<figure>
<img src="https://s2.loli.net/2023/11/03/qQMTAkGF7NIxyfW.png"
alt="image-20231028080113030" />
<figcaption aria-hidden="true">image-20231028080113030</figcaption>
</figure>
<ul>
<li><p>针对SBP导致的重定向，其waing_for寄存器应该是EXE
Stage的PTNT信号</p>
<ul>
<li>若下一个cycle没有得到该信号，则表示重定向正确，当前FIFO里的指令确实是无效指令，则free当前FIFO</li>
</ul></li>
<li><p>针对中断&amp;异常，会进入到中断服务程序去处理</p>
<ul>
<li><p>如果ISR指令很多，则mret指令迟迟不能遇到-&gt;waiting_for信号迟迟不能拉高</p></li>
<li><p>此时一个FIFO相当于一直都是not
free的，此时PPF退化成单一FIFO</p></li>
<li><p>设置一个Timer计数器，当Timer达到一定值的时候，丢弃FIFO里的内容</p>
<blockquote>
<p>有利于分支指令、不利于ISR的返回</p>
</blockquote>
<figure>
<img src="https://s2.loli.net/2023/11/03/BHGQX4CUYs6IrEz.png"
alt="image-20231028081111125" />
<figcaption aria-hidden="true">image-20231028081111125</figcaption>
</figure></li>
</ul></li>
</ul></li>
</ol>
<h3 id="性能分析">性能分析</h3>
<ol type="1">
<li><p>RISC-V中各种分支指令的比例:</p>
<ul>
<li>JAL：一定跳转，且跳转地址可以通过pc+offset得到, 占比</li>
<li>JALR：一定跳转，且跳转地址需要将pc+register才可以得到, 占比</li>
<li>Branch(条件分支指令): 跳转与否取决于跟寄存器值的比较, 占比</li>
<li>ecall</li>
<li>mret</li>
<li><label><input type="checkbox" checked="" />TODO:
也可以用xyz等符号来表示</label></li>
</ul></li>
</ol>
<h4 id="中断返回加速">中断返回加速</h4>
<h4 id="增加的硬件">增加的硬件</h4>
<h2 id="dual-fifo-性能分析">Dual FIFO 性能分析</h2>
<h3 id="c约定c-convention">C约定(C convention)</h3>
<blockquote>
<p>RISC-V寄存器即函数调用约定，遵守该约定在能复用别人的代码</p>
</blockquote>
<p>在RISC-V 32IMC指令集中，分支指令一共有如下两种:</p>
<ol type="1">
<li><p>JAL, JALR：主要在函数跳转的时候使用:</p>
<ul>
<li>在下面的代码中，main通过JAL跳转到add函数第一条指令</li>
<li>add通过ret指令返回到main函数</li>
</ul>
<blockquote>
<p>ret指令是伪指令，等价于<code>jalr x0, x1, 0</code></p>
</blockquote></li>
<li><p>B-Type: 主要用于控制程序流，做条件判断:</p>
<ul>
<li>在add内部的while循里，通过bgtz来判断循环的执行</li>
<li>通过bgtz跳转到while循环内第一条指令</li>
</ul></li>
<li><p>RISC-V寄存器约定, 假设函数A调用B:</p>
<ul>
<li>ra, sp, a0-a17, t0-t6由A负责保存到栈上，B直接使用无需保存</li>
<li>s0-s11由B负责保存，返回到A的时候，需要将s0-s11恢复 <img
src="https://s2.loli.net/2023/11/03/OBTGigK2x8JZQXE.png" /></li>
</ul></li>
<li><p>函数调用vs控制程序流:</p>
<ul>
<li>函数调用需要遵守C约定，父函数跟子函数需要将需要保存的寄存器保存到栈上</li>
<li>控制程序流只是pc的改变，不需要保存寄存器</li>
<li>控制程序流不需要返回，函数调用需要返回</li>
</ul></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sum += n;</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> sum = add(n); <span class="comment">// function call</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/11/03/QEt2jCfgzkPR6u7.png" /></p>
<h3 id="函数调用">函数调用</h3>
<ol type="1">
<li><p>函数A调用B的场景:</p>
<ul>
<li>A减少SP，保存重要的通用寄存器，保存ra</li>
<li>通过JAL, JALR跳转到B的第一条指令</li>
<li>执行B的指令，调用ret返回到A <img
src="https://s2.loli.net/2023/11/03/AiBv6JzYhR5FcSd.png"
alt="image-20231103220929902" /></li>
</ul></li>
<li><p>dual FIFO带来的优化:</p>
<ul>
<li>由于FIFO总共的容量为5，假设FIFO里预取的平均指令为2条</li>
<li>在函数调用的时候，可以切换到空闲的FIFO，从而保存2条预取的指令</li>
<li>函数返回的时候，可以直接从原来的FIFO里读取指令:
<ul>
<li>避免4次ITCM访问(2条重复取指+2条Nop指令)</li>
<li>避免2次Nop指令造成的流水线冲刷</li>
<li>提前1个cycle完成函数调用返回</li>
</ul></li>
</ul></li>
</ol>
<h3 id="分支跳转">分支跳转</h3>
<blockquote>
<p>dual FIFO会增加哪些硬件，量化描述</p>
</blockquote>
<ol type="1">
<li>分支指令的场景:
<ul>
<li>译码期间分支预测跳转，切换到空闲的FIFO取指</li>
<li>ALU判断分支预测正确，冲刷掉之前的FIFO，在新的FIFO取指</li>
<li>ALU判断分支预测错误，返回到之前的FIFO顺序执行 <img
src="https://s2.loli.net/2023/11/03/SUmgFJ9rPx68nVE.png" /></li>
</ul></li>
<li>dual FIFO带来的优化:
<ul>
<li>预测正确的情况下，在时序取指上没有新能提升</li>
<li>预测错误的情况下，可以直接返回之前的FIFO继续执行:
<ul>
<li>避免4次ITCM访问(2条重复取指+2条Nop指令)</li>
<li>避免2次Nop指令造成的流水线冲刷</li>
<li>提前2个cycle取到正确的指令</li>
</ul></li>
<li>静态分支预测器有50%的预测准确率</li>
</ul></li>
</ol>
<h3 id="异常中断">异常&amp;中断</h3>
<ol type="1">
<li>异常&amp;中断的场景:
<ul>
<li>外部中断出发之后，切换到空闲的FIFO执行<u>中断处理程序(ISR)</u></li>
<li>ID
Stage检测到ecall指令后，1个cycle后触发软件中断，此时切换到空闲的FIFO进行处理</li>
<li>ID Stage检测到mret指令之后，返回到之前的FIFO继续顺序执行 <img
src="https://s2.loli.net/2023/11/03/bmAOuFYGtH6qNK7.png" /></li>
</ul></li>
<li>dual FIFO带来的优化:
<ul>
<li>避免5次ITCM访问(3条重复取指+2条Nop指令)</li>
<li>避免2次Nop指令造成的流水线冲刷</li>
<li>提前2个cycle取到顺序执行的指令</li>
</ul></li>
</ol>
<h3 id="数学量化">数学量化</h3>
<ul>
<li>25% loads</li>
<li>10% stores</li>
<li>11% branches</li>
<li>2% jumps</li>
<li>52% R-type or I-type</li>
</ul>
<ol type="1">
<li><p>假设程序里指令出现的概率如下所示:</p>
<table>
<thead>
<tr>
<th>指令类型</th>
<th>出现概率</th>
</tr>
</thead>
<tbody>
<tr>
<td>JAL, JALR</td>
<td>x</td>
</tr>
<tr>
<td>B-Type</td>
<td>y</td>
</tr>
<tr>
<td>Interrupt, ECALL, MRET</td>
<td>z</td>
</tr>
<tr>
<td>alu</td>
<td>1-(x+y+z)</td>
</tr>
</tbody>
</table>
<p>假设分支预测器的预测跳转，但是实际不跳转的概率为<code>p</code></p></li>
<li><p>减少的访问ITCM比例: <span
class="math inline">\(\frac{4x+4py+5z}{1+4x+4py+5z}\)</span></p></li>
<li><p>减少NOP指令导致的冲刷的比例: <span
class="math inline">\(\frac{2x+2py+2z}{1+2x+2py+2z}\)</span></p></li>
<li><p>减少的返回的cycle比例: <span
class="math inline">\(\frac{1x+2py+2z}{1+1x+2py+2z}\)</span></p></li>
<li><p>硬件代价:</p>
<ul>
<li>第二个5*16 FIFO(5*16 bits寄存器，FIFO电路)</li>
<li>waiting_for寄存器，及其更新电路</li>
<li>free寄存器，及其更新电路</li>
<li>在2个FIFO里选择数据的2选1 MUX</li>
</ul></li>
</ol>
<ul class="task-list">
<li><label><input type="checkbox" />TODO:
每种指令的比例，每种类型的指令的影响单独分析，列出参考的文献</label></li>
<li><label><input type="checkbox" />TODO:
增加占比，编译所有的benchmark里面的指令，得到反汇编文件里的指令占比</label></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RISC-V/" rel="tag"># RISC-V</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/03/23/riscv-trap/" rel="prev" title="RISC-V 异常和中断">
                  <i class="fa fa-chevron-left"></i> RISC-V 异常和中断
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/28/riscv-out-of-order/" rel="next" title="RISC-V 乱序执行">
                  RISC-V 乱序执行 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FuJie</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">441k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:41</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
